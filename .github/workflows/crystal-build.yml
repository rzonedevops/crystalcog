name: Crystal Build and Test

on:
  push:
    branches:
      - main
    paths:
      - 'src/**'
      - 'spec/**'
      - 'shard.yml'
      - '.github/workflows/crystal-build.yml'
  pull_request:
    branches:
      - main
    paths:
      - 'src/**'
      - 'spec/**'
      - 'shard.yml'
      - '.github/workflows/crystal-build.yml'
  workflow_dispatch:
    inputs:
      run_comprehensive_tests:
        description: 'Run comprehensive test suite'
        required: false
        default: 'false'
        type: boolean

env:
  CRYSTAL_VERSION: 1.10.1

jobs:
  crystal-build:
    name: Crystal Build and Test
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Install Crystal
      uses: crystal-lang/install-crystal@v1
      with:
        crystal: ${{ env.CRYSTAL_VERSION }}

    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y libsqlite3-dev libevent-dev libssl-dev librocksdb-dev

    - name: Install dependencies
      id: install_deps
      run: |
        echo "Installing Crystal dependencies..."
        shards install 2>&1 | tee install.log
      continue-on-error: true

    - name: Check dependency installation
      if: steps.install_deps.outcome == 'failure'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          
          // Read the install log
          let installLog = '';
          try {
            installLog = fs.readFileSync('install.log', 'utf8');
          } catch (error) {
            installLog = 'Could not read install log';
          }
          
          // Create issue for dependency installation failure
          const issueTitle = '[Crystal Build] Dependency Installation Failed';
          const issueBody = [
            '## Crystal Dependency Installation Error',
            '',
            'The Crystal dependency installation failed during the automated build process.',
            '',
            '### Error Log',
            '```',
            installLog,
            '```',
            '',
            '### Diagnostic Information',
            '- **Crystal Version**: ' + process.env.CRYSTAL_VERSION,
            '- **Build Trigger**: ' + context.eventName,
            '- **Branch**: ' + (context.ref || 'unknown'),
            '- **Commit**: ' + (context.sha || 'unknown'),
            '',
            '### Possible Causes',
            '- Missing or incorrect dependency specifications in `shard.yml`',
            '- Network issues downloading dependencies',
            '- Version conflicts between dependencies',
            '- Crystal version compatibility issues',
            '',
            '### Suggested Actions',
            '1. Check `shard.yml` for correct dependency versions',
            '2. Verify Crystal version compatibility',
            '3. Check for dependency conflicts',
            '4. Review dependency documentation for breaking changes',
            '',
            '---',
            '*This issue was automatically generated by the Crystal build workflow.*'
          ].join('\n');

          await github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: issueTitle,
            body: issueBody,
            labels: ['bug', 'crystal-build', 'dependencies', 'automated']
          });
          
          core.setFailed('Dependency installation failed');

    - name: Build Crystal project
      id: build
      run: |
        echo "Building Crystal project..."
        crystal build --error-trace src/crystalcog.cr 2>&1 | tee build.log
      continue-on-error: true

    - name: Check build results
      if: steps.build.outcome == 'failure'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          
          // Read the build log
          let buildLog = '';
          try {
            buildLog = fs.readFileSync('build.log', 'utf8');
          } catch (error) {
            buildLog = 'Could not read build log';
          }
          
          // Parse build errors for diagnostic information
          const parseErrors = (log) => {
            const errors = [];
            const lines = log.split('\n');
            let currentError = null;
            
            for (const line of lines) {
              // Crystal error format: "Error in file:line:column: message"
              const errorMatch = line.match(/Error in (.+?):(\d+):(\d+): (.+)/);
              if (errorMatch) {
                if (currentError) errors.push(currentError);
                currentError = {
                  file: errorMatch[1],
                  line: errorMatch[2],
                  column: errorMatch[3],
                  message: errorMatch[4],
                  context: []
                };
              } else if (currentError && line.trim()) {
                currentError.context.push(line);
              }
            }
            if (currentError) errors.push(currentError);
            return errors;
          };
          
          const errors = parseErrors(buildLog);
          
          // Generate diagnostic explanations
          const generateDiagnostic = (error) => {
            const { file, line, message } = error;
            let diagnostic = `**File**: \`${file}\` (line ${line})\n**Error**: ${message}\n\n`;
            
            // Common error patterns and explanations
            if (message.includes('undefined method')) {
              diagnostic += '**Diagnosis**: Method not found. This usually means:\n';
              diagnostic += '- The method is not defined in the class/module\n';
              diagnostic += '- Wrong method name (typo)\n';
              diagnostic += '- Missing required include/require statement\n';
              diagnostic += '- Incorrect object type being used\n\n';
            } else if (message.includes('undefined constant')) {
              diagnostic += '**Diagnosis**: Constant not found. This usually means:\n';
              diagnostic += '- Constant is not defined\n';
              diagnostic += '- Missing require statement\n';
              diagnostic += '- Wrong namespace/module path\n';
              diagnostic += '- Typo in constant name\n\n';
            } else if (message.includes('type must be')) {
              diagnostic += '**Diagnosis**: Type mismatch. This usually means:\n';
              diagnostic += '- Incorrect type annotation\n';
              diagnostic += '- Value of wrong type being assigned\n';
              diagnostic += '- Missing type casting\n';
              diagnostic += '- Generic type parameter issues\n\n';
            } else if (message.includes('no overload matches')) {
              diagnostic += '**Diagnosis**: Method signature mismatch. This usually means:\n';
              diagnostic += '- Wrong number of arguments\n';
              diagnostic += '- Arguments of wrong types\n';
              diagnostic += '- Missing method overload\n';
              diagnostic += '- Incorrect generic type parameters\n\n';
            } else {
              diagnostic += '**Diagnosis**: General build error. Check the error message for specific details.\n\n';
            }
            
            return diagnostic;
          };
          
          // Create issue for build failure
          const issueTitle = '[Crystal Build] Compilation Failed';
          let issueBody = [
            '## Crystal Build Compilation Error',
            '',
            'The Crystal compilation failed during the automated build process.',
            '',
            '### Build Information',
            '- **Crystal Version**: ' + process.env.CRYSTAL_VERSION,
            '- **Build Trigger**: ' + context.eventName,
            '- **Branch**: ' + (context.ref || 'unknown'),
            '- **Commit**: ' + (context.sha || 'unknown'),
            '',
            '### Errors Found',
            ''
          ];
          
          if (errors.length > 0) {
            errors.forEach((error, index) => {
              issueBody.push(`#### Error ${index + 1}`);
              issueBody.push(generateDiagnostic(error));
              if (error.context.length > 0) {
                issueBody.push('**Context:**');
                issueBody.push('```');
                issueBody.push(error.context.join('\n'));
                issueBody.push('```');
                issueBody.push('');
              }
            });
          } else {
            issueBody.push('No specific errors parsed. Full build log:');
            issueBody.push('```');
            issueBody.push(buildLog);
            issueBody.push('```');
          }
          
          issueBody.push('### Suggested Actions');
          issueBody.push('1. Review the error messages above');
          issueBody.push('2. Check syntax and type correctness in affected files');
          issueBody.push('3. Verify all required dependencies are properly imported');
          issueBody.push('4. Ensure Crystal version compatibility');
          issueBody.push('5. Run `crystal build --error-trace` locally for detailed debugging');
          issueBody.push('');
          issueBody.push('---');
          issueBody.push('*This issue was automatically generated by the Crystal build workflow.*');

          await github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: issueTitle,
            body: issueBody.join('\n'),
            labels: ['bug', 'crystal-build', 'compilation-error', 'automated']
          });
          
          core.setFailed('Crystal compilation failed');

    - name: Run tests
      id: test
      if: steps.build.outcome == 'success'
      run: |
        echo "Running Crystal tests..."
        crystal spec --error-trace 2>&1 | tee test.log
      continue-on-error: true

    - name: Check test results
      if: steps.test.outcome == 'failure' && steps.build.outcome == 'success'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          
          // Read the test log
          let testLog = '';
          try {
            testLog = fs.readFileSync('test.log', 'utf8');
          } catch (error) {
            testLog = 'Could not read test log';
          }
          
          // Create issue for test failure
          const issueTitle = '[Crystal Build] Tests Failed';
          const issueBody = [
            '## Crystal Test Failure',
            '',
            'The Crystal tests failed during the automated build process.',
            '',
            '### Test Information',
            '- **Crystal Version**: ' + process.env.CRYSTAL_VERSION,
            '- **Build Trigger**: ' + context.eventName,
            '- **Branch**: ' + (context.ref || 'unknown'),
            '- **Commit**: ' + (context.sha || 'unknown'),
            '',
            '### Test Log',
            '```',
            testLog,
            '```',
            '',
            '### Diagnostic Information',
            'Test failures can indicate:',
            '- Logic errors in the code',
            '- Incorrect test expectations',
            '- Environmental issues',
            '- Dependency version conflicts',
            '- Race conditions in concurrent tests',
            '',
            '### Suggested Actions',
            '1. Review failing test output for specific assertions',
            '2. Run tests locally to reproduce the issue',
            '3. Check for environmental differences',
            '4. Verify test data and expectations are correct',
            '5. Consider adding more debugging output to tests',
            '',
            '---',
            '*This issue was automatically generated by the Crystal build workflow.*'
          ].join('\n');

          await github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: issueTitle,
            body: issueBody,
            labels: ['bug', 'crystal-build', 'test-failure', 'automated']
          });

    - name: Build additional targets
      if: steps.build.outcome == 'success'
      run: |
        echo "Building additional Crystal targets..."
        
        # Create bin directory for build outputs
        mkdir -p bin
        
        # Build cogutil library
        if [ -f "src/cogutil/cogutil.cr" ]; then
          echo "Building cogutil..."
          crystal build src/cogutil/cogutil.cr -o bin/cogutil || echo "cogutil build failed"
        fi
        
        # Build atomspace library
        if [ -f "src/atomspace/atomspace.cr" ]; then
          echo "Building atomspace..."
          crystal build src/atomspace/atomspace.cr -o bin/atomspace || echo "atomspace build failed"
        fi
        
        # Build opencog library
        if [ -f "src/opencog/opencog.cr" ]; then
          echo "Building opencog..."
          crystal build src/opencog/opencog.cr -o bin/opencog || echo "opencog build failed"
        fi

    - name: Run basic functionality tests
      if: steps.build.outcome == 'success'
      run: |
        echo "Running basic functionality tests..."
        
        if [ -f "test_basic.cr" ]; then
          echo "Running test_basic.cr..."
          crystal run test_basic.cr || echo "Basic test failed"
        fi
        
        if [ -f "test_pln.cr" ]; then
          echo "Running test_pln.cr..."
          crystal run test_pln.cr || echo "PLN test failed"
        fi

    - name: Upload build artifacts
      if: steps.build.outcome == 'success'
      uses: actions/upload-artifact@v4
      with:
        name: crystal-build-artifacts
        path: |
          crystalcog
          bin/
          *.log
        retention-days: 7
        if-no-files-found: ignore

    - name: Build success notification
      if: steps.build.outcome == 'success' && steps.test.outcome == 'success'
      run: |
        echo "âœ… Crystal build and tests completed successfully!"
        echo "Build artifacts are available for download."
        
    - name: Trigger comprehensive testing
      if: github.event.inputs.run_comprehensive_tests == 'true'
      uses: actions/github-script@v7
      with:
        script: |
          await github.rest.actions.createWorkflowDispatch({
            owner: context.repo.owner,
            repo: context.repo.repo,
            workflow_id: 'crystal-comprehensive-ci.yml',
            ref: context.ref,
            inputs: {
              run_benchmarks: 'true',
              test_coverage: 'true'
            }
          });
          
    - name: Check for test patterns and improvements
      if: always()
      uses: actions/github-script@v7
      with:
        script: |
          // Analyze test results and provide recommendations
          const buildSuccess = '${{ steps.build.outcome }}' === 'success';
          const testSuccess = '${{ steps.test.outcome }}' === 'success';
          
          if (buildSuccess && testSuccess) {
            console.log('âœ… All tests passed! Consider running comprehensive testing for more coverage.');
          } else if (!buildSuccess) {
            console.log('ðŸ”§ Build failed. Check compilation errors and dependencies.');
          } else if (!testSuccess) {
            console.log('ðŸ§ª Tests failed. Review test failures and consider improving test stability.');
          }
          
          // Check if comprehensive testing should be recommended
          if (buildSuccess && testSuccess && context.eventName === 'pull_request') {
            console.log('ðŸ’¡ Tip: For pull requests affecting core components, consider running comprehensive tests.');
          }