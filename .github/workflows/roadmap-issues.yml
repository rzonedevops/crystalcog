name: Generate Development Roadmap Issues

on:
  workflow_dispatch:
    inputs:
      force_recreate:
        description: 'Force recreate all issues (will close existing ones)'
        required: false
        default: 'false'
        type: boolean
      roadmap_section:
        description: 'Specific roadmap section to process (leave empty for all)'
        required: false
        default: ''
        type: string
      roadmap_file:
        description: 'Roadmap file to process'
        required: false
        default: 'DEVELOPMENT-ROADMAP.md'
        type: choice
        options:
          - 'DEVELOPMENT-ROADMAP.md'
          - 'AGENT-ZERO-GENESIS.md'
  schedule:
    # Run weekly on Mondays at 10 AM UTC to check for new roadmap tasks
    - cron: '0 10 * * 1'
  push:
    branches:
      - main
    paths:
      - 'DEVELOPMENT-ROADMAP.md'
      - 'AGENT-ZERO-GENESIS.md'

env:
  ROADMAP_FILE: ${{ github.event.inputs.roadmap_file || 'DEVELOPMENT-ROADMAP.md' }}

jobs:
  verify-roadmap:
    name: Verify Roadmap is Up-to-Date
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Verify roadmap file exists
      run: |
        if [ ! -f "${{ env.ROADMAP_FILE }}" ]; then
          echo "âŒ DEVELOPMENT-ROADMAP.md not found!"
          exit 1
        fi
        echo "âœ… DEVELOPMENT-ROADMAP.md found"

    - name: Check roadmap structure
      run: |
        # Verify essential sections exist (support both formats)
        if ! grep -q "## Next Steps\|## Next Development Steps" "${{ env.ROADMAP_FILE }}"; then
          echo "âŒ 'Next Steps' or 'Next Development Steps' section not found in roadmap"
          exit 1
        fi
        
        if ! grep -q "### Immediate Actions\|\*\*Immediate (Week 1-2)\*\*" "${{ env.ROADMAP_FILE }}"; then
          echo "âŒ 'Immediate Actions' section or immediate timeline not found in roadmap"
          exit 1
        fi
        
        echo "âœ… Roadmap structure verified"

    - name: Validate roadmap content with parser
      run: |
        if [ -f "scripts/validate-roadmap.js" ]; then
          echo "ðŸ” Running detailed roadmap validation..."
          node scripts/validate-roadmap.js
        else
          echo "âš ï¸ Validation script not found, skipping detailed validation"
        fi

    - name: Check roadmap freshness
      id: freshness
      run: |
        # Check when the roadmap was last updated
        LAST_MODIFIED=$(git log -1 --format="%at" -- "${{ env.ROADMAP_FILE }}")
        CURRENT_TIME=$(date +%s)
        DAYS_OLD=$(( (CURRENT_TIME - LAST_MODIFIED) / 86400 ))
        
        echo "days_old=$DAYS_OLD" >> $GITHUB_OUTPUT
        echo "last_modified=$(date -d @$LAST_MODIFIED '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_OUTPUT
        
        if [ $DAYS_OLD -gt 30 ]; then
          echo "âš ï¸ Roadmap is $DAYS_OLD days old (last updated: $(date -d @$LAST_MODIFIED '+%Y-%m-%d'))"
          echo "Consider reviewing and updating the roadmap"
        else
          echo "âœ… Roadmap is current ($DAYS_OLD days old)"
        fi

    outputs:
      roadmap_age: ${{ steps.freshness.outputs.days_old }}
      last_updated: ${{ steps.freshness.outputs.last_modified }}

  generate-issues:
    name: Generate Issues from Roadmap
    needs: verify-roadmap
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Parse roadmap and create issues
      uses: actions/github-script@v7
      env:
        ROADMAP_LAST_UPDATED: ${{ needs.verify-roadmap.outputs.last_updated }}
        ROADMAP_AGE: ${{ needs.verify-roadmap.outputs.roadmap_age }}
        ROADMAP_FILE: ${{ env.ROADMAP_FILE }}
      with:
        script: |
          const fs = require('fs');
          
          // Read the roadmap file
          const roadmapContent = fs.readFileSync(process.env.ROADMAP_FILE, 'utf8');
          
          // Parse the roadmap sections with actionable items
          const parseActionableItems = (content) => {
            const sections = [];
            
            // Find "Next Steps" or "Next Development Steps" section
            const nextStepsMatch = content.match(/## Next (?:Development )?Steps\n\n([\s\S]*?)(?=\n## |$)/);
            if (!nextStepsMatch) {
              console.log('No "Next Steps" or "Next Development Steps" section found');
              return sections;
            }
            
            const nextStepsContent = nextStepsMatch[1];
            console.log(`Found Next Steps section with ${nextStepsContent.length} characters`);
            
            // Parse subsections like "Immediate Actions", "Phase 2 Implementation", etc.
            const subsectionRegex = /### ([^#\n]+)\n\n([\s\S]*?)(?=\n### |\n## |$)/g;
            let subsectionMatch;
            let foundSubsections = false;
            
            while ((subsectionMatch = subsectionRegex.exec(nextStepsContent)) !== null) {
              foundSubsections = true;
              const [, sectionTitle, sectionContent] = subsectionMatch;
              console.log(`Processing section: "${sectionTitle.trim()}"`);
              
              // Skip sections that don't contain actionable items
              if (sectionTitle.includes('Summary') || sectionTitle.includes('Resources') || 
                  sectionTitle.includes('Metrics') || sectionTitle.includes('Workflow')) {
                console.log(`  Skipping non-actionable section: ${sectionTitle.trim()}`);
                continue;
              }
              
              // Parse numbered items with tasks
              const itemRegex = /(\d+)\.\s\*\*([^*]+)\*\*[^\n]*\n((?:\s*-\s[^\n]*\n?)*)/g;
              let itemMatch;
              
              while ((itemMatch = itemRegex.exec(sectionContent)) !== null) {
                const [, itemNumber, itemTitle, tasksText] = itemMatch;
                console.log(`  Found item ${itemNumber}: "${itemTitle.trim()}"`);
                const tasks = [];
                
                // Parse individual tasks with standard markdown checkboxes
                const taskRegex = /\s*-\s\[([^\]]*)\]\s(.+)/g;
                let taskMatch;
                while ((taskMatch = taskRegex.exec(tasksText)) !== null) {
                  const [, status, description] = taskMatch;
                  tasks.push({
                    completed: status.trim() === 'x',
                    description: description.trim(),
                    format: 'checkbox'
                  });
                }
                
                // NEW: Parse tasks with checkmark emojis (completed items)
                const checkmarkRegex = /\s*-\sâœ…\s(.+)/g;
                let checkmarkMatch;
                while ((checkmarkMatch = checkmarkRegex.exec(tasksText)) !== null) {
                  const [, description] = checkmarkMatch;
                  tasks.push({
                    completed: true,
                    description: description.trim(),
                    format: 'checkmark'
                  });
                }
                
                // NEW: Parse tasks without checkmarks or checkboxes (assume incomplete)
                const lines = tasksText.split('\n').filter(line => line.trim());
                for (const line of lines) {
                  const trimmedLine = line.trim();
                  // Skip if already processed as checkbox or checkmark
                  if (trimmedLine.match(/^\s*-\s\[.*\]/) || trimmedLine.match(/^\s*-\sâœ…/)) {
                    continue;
                  }
                  // Match plain bullet points
                  const plainMatch = trimmedLine.match(/^\s*-\s(.+)/);
                  if (plainMatch) {
                    const [, description] = plainMatch;
                    // Only add if it doesn't contain completed indicators
                    if (!description.includes('âœ…') && !description.includes('[x]')) {
                      tasks.push({
                        completed: false,
                        description: description.trim(),
                        format: 'plain'
                      });
                    }
                  }
                }
                
                console.log(`    Found ${tasks.length} tasks (${tasks.filter(t => !t.completed).length} incomplete)`);
                
                if (tasks.length > 0) {
                  sections.push({
                    section: sectionTitle.trim(),
                    itemNumber: parseInt(itemNumber),
                    itemTitle: itemTitle.trim(),
                    tasks: tasks
                  });
                }
              }
            }
            
            // If no ### subsections found, try direct numbered format (for AGENT-ZERO-GENESIS.md)
            if (!foundSubsections) {
              console.log('No ### subsections found, trying direct numbered format');
              const directItemRegex = /(\d+)\.\s\*\*([^*:]+)[^:]*\*\*:\s*\n((?:\s*-\s[^\n]*\n?)*)/g;
              let directItemMatch;
              
              while ((directItemMatch = directItemRegex.exec(nextStepsContent)) !== null) {
                const [, itemNumber, sectionTitle, tasksText] = directItemMatch;
                console.log(`Processing direct section: "${sectionTitle.trim()}"`);
                const tasks = [];
                
                // Parse individual tasks with standard markdown checkboxes
                const taskRegex = /\s*-\s\[([^\]]*)\]\s(.+)/g;
                let taskMatch;
                while ((taskMatch = taskRegex.exec(tasksText)) !== null) {
                  const [, status, description] = taskMatch;
                  tasks.push({
                    completed: status.trim() === 'x',
                    description: description.trim(),
                    format: 'checkbox'
                  });
                }
                
                // NEW: Parse tasks with checkmark emojis (completed items)
                const checkmarkRegex = /\s*-\sâœ…\s(.+)/g;
                let checkmarkMatch;
                while ((checkmarkMatch = checkmarkRegex.exec(tasksText)) !== null) {
                  const [, description] = checkmarkMatch;
                  tasks.push({
                    completed: true,
                    description: description.trim(),
                    format: 'checkmark'
                  });
                }
                
                // NEW: Parse tasks without checkmarks or checkboxes (assume incomplete)
                const lines = tasksText.split('\n').filter(line => line.trim());
                for (const line of lines) {
                  const trimmedLine = line.trim();
                  // Skip if already processed as checkbox or checkmark
                  if (trimmedLine.match(/^\s*-\s\[.*\]/) || trimmedLine.match(/^\s*-\sâœ…/)) {
                    continue;
                  }
                  // Match plain bullet points
                  const plainMatch = trimmedLine.match(/^\s*-\s(.+)/);
                  if (plainMatch) {
                    const [, description] = plainMatch;
                    // Only add if it doesn't contain completed indicators
                    if (!description.includes('âœ…') && !description.includes('[x]')) {
                      tasks.push({
                        completed: false,
                        description: description.trim(),
                        format: 'plain'
                      });
                    }
                  }
                }
                
                console.log(`    Found ${tasks.length} tasks (${tasks.filter(t => !t.completed).length} incomplete)`);
                
                if (tasks.length > 0) {
                  sections.push({
                    section: sectionTitle.trim(),
                    itemNumber: parseInt(itemNumber),
                    itemTitle: itemTitle.trim(),
                    tasks: tasks
                  });
                }
              }
            }
            
            console.log(`Total sections with actionable items: ${sections.length}`);
            return sections;
          };
          
          // Parse Success Metrics section for additional trackable items
          const parseSuccessMetrics = (content) => {
            const metricsMatch = content.match(/### Success Metrics\n\n([\s\S]*?)(?=\n### |\n## |$)/);
            if (!metricsMatch) {
              console.log('No Success Metrics section found');
              return [];
            }
            
            const metricsContent = metricsMatch[1];
            console.log(`Found Success Metrics section with ${metricsContent.length} characters`);
            const items = [];
            
            // Parse bullet points with standard markdown checkboxes
            const metricRegex = /-\s\[([^\]]*)\]\s(.+)/g;
            let match;
            while ((match = metricRegex.exec(metricsContent)) !== null) {
              const [, status, description] = match;
              if (status.trim() !== 'x') {
                items.push({
                  section: 'Success Metrics',
                  itemNumber: 0,
                  itemTitle: 'Success Metrics',
                  tasks: [{
                    completed: false,
                    description: description.trim(),
                    format: 'checkbox'
                  }]
                });
              }
            }
            
            // NEW: Parse metrics with checkmark emojis  
            const checkmarkMetricRegex = /-\sâœ…\s(.+)/g;
            let checkmarkMatch;
            while ((checkmarkMatch = checkmarkMetricRegex.exec(metricsContent)) !== null) {
              const [, description] = checkmarkMatch;
              // Skip if it's already completed (we don't create issues for completed items)
              console.log(`  Found completed metric: ${description.trim()}`);
            }
            
            // NEW: Parse plain metrics (assume incomplete if no checkbox or checkmark)
            const lines = metricsContent.split('\n').filter(line => line.trim().startsWith('-'));
            for (const line of lines) {
              const trimmedLine = line.trim();
              // Skip if already processed as checkbox or checkmark
              if (trimmedLine.match(/^\s*-\s\[.*\]/) || trimmedLine.match(/^\s*-\sâœ…/)) {
                continue;
              }
              // Match plain bullet points
              const plainMatch = trimmedLine.match(/^\s*-\s(.+)/);
              if (plainMatch) {
                const [, description] = plainMatch;
                // Only add if it doesn't contain completed indicators
                if (!description.includes('âœ…') && !description.includes('[x]')) {
                  items.push({
                    section: 'Success Metrics',
                    itemNumber: 0,
                    itemTitle: 'Success Metrics',
                    tasks: [{
                      completed: false,
                      description: description.trim(),
                      format: 'plain'
                    }]
                  });
                }
              }
            }
            
            console.log(`Found ${items.length} incomplete metrics items`);
            return items;
          };
          
          const actionableItems = parseActionableItems(roadmapContent);
          const metricsItems = parseSuccessMetrics(roadmapContent);
          const allItems = [...actionableItems, ...metricsItems];
          
          console.log(`Found ${allItems.length} items with actionable tasks`);
          
          // Filter by section if specified
          const targetSection = context.payload.inputs?.roadmap_section || '';
          const filteredItems = targetSection ? 
            allItems.filter(item => item.section.toLowerCase().includes(targetSection.toLowerCase())) : 
            allItems;
          
          console.log(`Processing ${filteredItems.length} items${targetSection ? ` (filtered by: ${targetSection})` : ''}`);
          
          // Get existing issues to avoid duplicates
          const existingIssues = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            labels: 'roadmap',
            state: 'all',
            per_page: 100
          });
          
          const existingTitles = new Set(existingIssues.data.map(issue => issue.title));
          
          // Force recreate option
          const forceRecreate = context.payload.inputs?.force_recreate === 'true';
          if (forceRecreate) {
            console.log('Force recreate enabled - closing existing roadmap issues');
            for (const issue of existingIssues.data) {
              if (issue.state === 'open' && issue.labels.some(label => label.name === 'roadmap')) {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  state: 'closed'
                });
              }
            }
            existingTitles.clear();
          }
          
          // Create issues for incomplete tasks
          let createdCount = 0;
          let skippedCount = 0;
          
          for (const item of filteredItems) {
            const sectionLabel = item.section.toLowerCase()
              .replace(/[^a-z0-9]+/g, '-')
              .replace(/^-|-$/g, '');
            
            for (const task of item.tasks) {
              if (!task.completed) {
                const issueTitle = `[${item.section}] ${task.description}`;
                
                if (!existingTitles.has(issueTitle)) {
                  // Determine priority based on section
                  const getPriority = (section) => {
                    if (section.includes('Immediate')) return 'high';
                    if (section.includes('Phase 2')) return 'medium';
                    if (section.includes('Phase 3')) return 'medium';
                    if (section.includes('Metrics')) return 'low';
                    return 'medium';
                  };
                  
                  // Determine component tags based on task description
                  const getComponentTags = (description) => {
                    const tags = [];
                    const desc = description.toLowerCase();
                    if (desc.includes('cogutil')) tags.push('cogutil');
                    if (desc.includes('atomspace')) tags.push('atomspace');
                    if (desc.includes('opencog')) tags.push('opencog');
                    if (desc.includes('pln')) tags.push('pln');
                    if (desc.includes('ure')) tags.push('ure');
                    if (desc.includes('cogserver')) tags.push('cogserver');
                    if (desc.includes('moses')) tags.push('moses');
                    if (desc.includes('test')) tags.push('testing');
                    if (desc.includes('ci') || desc.includes('pipeline')) tags.push('ci-cd');
                    if (desc.includes('doc')) tags.push('documentation');
                    return tags;
                  };
                  
                  const priority = getPriority(item.section);
                  const componentTags = getComponentTags(task.description);
                  
                  const issueBody = [
                    `## Development Roadmap Task: ${item.section}`,
                    '',
                    'This task is part of the OpenCog to Crystal conversion development roadmap.',
                    '',
                    '### Task Description',
                    task.description,
                    '',
                    '### Context',
                    `- **Section**: ${item.section}`,
                    `- **Item**: ${item.itemTitle}`,
                    `- **Priority**: ${priority}`,
                    componentTags.length > 0 ? `- **Components**: ${componentTags.join(', ')}` : '',
                    '',
                    '### Reference',
                    `This task comes from the [Development Roadmap](${context.payload.repository.html_url}/blob/main/${process.env.ROADMAP_FILE}#next-steps).`,
                    '',
                    '### Acceptance Criteria',
                    '- [ ] Task implementation completed according to roadmap specifications',
                    '- [ ] Code follows Crystal best practices and project conventions',
                    '- [ ] Appropriate tests added or updated',
                    '- [ ] Documentation updated if required',
                    '- [ ] Performance impact assessed if applicable',
                    '- [ ] Update roadmap checkbox when complete: `- [x]`',
                    '',
                    '### Definition of Done',
                    '1. Implementation meets the task requirements',
                    '2. All tests pass (existing and new)',
                    '3. Code review completed',
                    '4. Documentation is up to date',
                    '5. Roadmap is updated to mark task as complete',
                    '',
                    '---',
                    '*This issue was automatically generated from the development roadmap. ' +
                    `Last roadmap update: ${process.env.ROADMAP_LAST_UPDATED}*`
                  ].filter(line => line !== '').join('\n');

                  try {
                    const labels = [
                      'roadmap', 
                      'crystal-conversion', 
                      sectionLabel, 
                      `priority-${priority}`,
                      ...componentTags
                    ].filter((label, index, arr) => arr.indexOf(label) === index); // Remove duplicates

                    const issue = await github.rest.issues.create({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      title: issueTitle,
                      body: issueBody,
                      labels: labels
                    });
                    
                    console.log(`âœ… Created issue: ${issueTitle}`);
                    createdCount++;
                  } catch (error) {
                    console.error(`âŒ Failed to create issue "${issueTitle}": ${error.message}`);
                  }
                } else {
                  console.log(`â­ï¸ Issue already exists: ${issueTitle}`);
                  skippedCount++;
                }
              }
            }
          }
          
          // Log summary
          console.log(`\nðŸ“Š Summary:`);
          console.log(`- Found ${filteredItems.length} roadmap items to process`);
          console.log(`- Created ${createdCount} new issues`);
          console.log(`- Skipped ${skippedCount} existing issues`);
          console.log(`- Roadmap age: ${process.env.ROADMAP_AGE} days`);
          
          // Create summary comment if running manually
          if (context.eventName === 'workflow_dispatch') {
            const summary = [
              '## Development Roadmap Issues Generation Summary',
              '',
              '### Processing Results',
              `- **Roadmap processed**: \`${process.env.ROADMAP_FILE}\``,
              `- **Last updated**: ${process.env.ROADMAP_LAST_UPDATED}`,
              `- **Age**: ${process.env.ROADMAP_AGE} days old`,
              `- **Section filter**: ${targetSection || 'All sections'}`,
              `- **Force recreate**: ${forceRecreate ? 'Yes' : 'No'}`,
              '',
              '### Issues Generated',
              `- âœ… **Created**: ${createdCount} new issues`,
              `- â­ï¸ **Skipped**: ${skippedCount} existing issues`,
              `- ðŸ“‹ **Items processed**: ${filteredItems.length}`,
              '',
              '### Labels Applied',
              '- `roadmap` - All roadmap-generated issues',
              '- `crystal-conversion` - Part of Crystal conversion project',
              '- `priority-{high,medium,low}` - Based on roadmap section',
              '- Component-specific labels (e.g., `cogutil`, `atomspace`)',
              '- Section-specific labels (e.g., `immediate-actions`)',
              '',
              '### Next Steps',
              '1. Review and assign the newly created issues',
              '2. Update roadmap checkboxes as tasks are completed',
              '3. Roadmap will be re-processed weekly or when updated',
              '',
              '---',
              `**View all roadmap issues**: [Issues with roadmap label](${context.payload.repository.html_url}/issues?q=is%3Aissue+label%3Aroadmap)`
            ].join('\n');

            // Look for existing summary issue
            const summaryIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'roadmap-tracking',
              state: 'open'
            });
            
            if (summaryIssues.data.length > 0) {
              // Update existing summary issue
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: summaryIssues.data[0].number,
                body: summary
              });
            } else {
              // Create new summary issue
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: 'Development Roadmap Issues Tracking',
                body: [
                  'This issue tracks the automatic generation of issues from the development roadmap.',
                  '',
                  summary
                ].join('\n'),
                labels: ['roadmap-tracking', 'tracking']
              });
            }
          }
          
          // Set outputs for downstream jobs
          core.setOutput('created_count', createdCount);
          core.setOutput('skipped_count', skippedCount);
          core.setOutput('total_items', filteredItems.length);

    outputs:
      created_count: ${{ steps.generate-issues.outputs.created_count }}
      skipped_count: ${{ steps.generate-issues.outputs.skipped_count }}
      total_items: ${{ steps.generate-issues.outputs.total_items }}

  notify-completion:
    name: Notify Completion
    needs: [verify-roadmap, generate-issues]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
    - name: Summary notification
      run: |
        echo "ðŸŽ¯ Development Roadmap Issues Generation Complete"
        echo ""
        echo "ðŸ“Š Results:"
        echo "  - Roadmap age: ${{ needs.verify-roadmap.outputs.roadmap_age }} days"
        echo "  - Created issues: ${{ needs.generate-issues.outputs.created_count || 0 }}"
        echo "  - Skipped existing: ${{ needs.generate-issues.outputs.skipped_count || 0 }}"
        echo "  - Total items processed: ${{ needs.generate-issues.outputs.total_items || 0 }}"
        echo ""
        echo "âœ… Workflow completed successfully!"